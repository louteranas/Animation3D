#version 430 core
#define M_PI 3.14159265358979323846

layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform float shininess;
uniform float eta;
uniform vec3 bbmin;
uniform vec3 bbmax;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;
uniform bool blinnPhong;
uniform bool transparent;
uniform int numBounds;
uniform int alternating;

#define limit 5
#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.000001


struct hitinfo_t {
    vec4 t;
    int hit_vptr;
    vec3 coeffs;
    bool plan;
};

struct intersection_t {
        hitinfo_t h;
        vec4 Normals;
        vec4 Direction;
        vec4 Colors;
        vec4 Origin;
        float Fresnel;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};

float fresnelCoeff(float cosThethaD, float etaN){
     // Ci coeff 
     float Ci = pow(max(EPS, (pow(etaN, 2) - (1 - pow(cosThethaD, 2)))), 0.5);
     // Fs coef
     float fracFs = (cosThethaD - Ci) / (cosThethaD + Ci);
     float Fs = pow(abs(fracFs), 2);
     // Fp coeff
     float fracFp = (pow(etaN,2)*cosThethaD - Ci) / (pow(etaN,2)*cosThethaD + Ci);
     float Fp = pow(abs(fracFp), 2);
     ///// Fresnel coeff
     float F = (Fs + Fp)/2;
     if(F > 1.0){
         return 1.0;
     }
     return F;
}

/* compute ambient lighting when the intersection is in the shadow of a light */
vec4 computeAmbientLighting(in vec4 vertColor){
    // ambient reflection param 
     float Ka = 0.2;
     // setting the ambiantLighting - Ca
     vec4 ambientLight = Ka * lightIntensity * vertColor;
    return ambientLight;
}

/* compute diffuse lighting */
vec4 computeDiffuseLighting(in vec4 vertColor, in vec4 vertNormal, in vec4 lightVector){
    vec4 diffuseLighting;
    // Diffuse reflection param 
    float Kd = 0.7;
    // setting the Diffuse lighting - Cd
    diffuseLighting = Kd * vertColor * lightIntensity * max(EPS, dot(vertNormal, lightVector));
    return diffuseLighting;
}

/**
* this fuction calculate the microfacet normal distribution D(thetaH)
* For more details about the variable names, check the TP page
**/
bool indicatrice(float cosThetaH){
     if(cosThetaH < 0){
          return false;
     }
     return true;
     // maybe it's okay because theta is positive 
     // if not, so the graph and lights are reversed and we have theta positive
}

float NormalDistrib(float cosThetaH, float alpha){
     if(!indicatrice(cosThetaH)){
          return 0;
     }
     float frac1 = 1 / (pow(cosThetaH, 4) * M_PI);
     float tanThetaSquare = (1 - pow(cosThetaH, 2))/pow(cosThetaH, 2);
     float frac2 = pow(alpha/100, 2)/ pow((pow(alpha/100, 2) + pow(tanThetaSquare, 2)), 2);
     return frac1 * frac2;
}

/**
* this fuction calculate the GGX distribution G1(thetaI/thetaO)
* For more details about the variable names, check the TP page
**/
float GGXDistrib(float cosTheta, float alpha){
     float tanThetaSquare = (1 - pow(cosTheta, 2))/pow(cosTheta, 2);
     float base = 1 + sqrt(1 + tanThetaSquare * pow(alpha/100, 2));
     return 2 / base;
}

/**
* this fuction calculate the specular lighting using the blinn-phing model
* For more details about the variable names, check the TP page
**/
vec4 specularLightingBP(in vec4 vertColor, float cosThethaD, vec4 halfVector, vec4 normal){
    return fresnelCoeff(cosThethaD,eta) * vertColor * pow(max(EPS, dot(normal, halfVector)), shininess) * lightIntensity;
}

/**
* this fuction calculate the specular lighting using the cook-torrance model
* For more details about the variable names, check the TP page
**/
vec4 specularLightingCT(in vec4 vertColor, float cosThethaD, vec4 halfVector, float alpha, vec4 normal, vec4 lightVector, vec4 eyeVector){
     float cosThetaH = dot(normal,halfVector);
     float cosThetaI = dot(normal,lightVector);
     float cosThetaO = dot(normal,eyeVector);
     float top = fresnelCoeff(cosThethaD,eta) * NormalDistrib(cosThetaH, alpha) * GGXDistrib(cosThetaI, alpha) * GGXDistrib(cosThetaO, alpha);
     float bottom = 4 * cosThetaI * cosThetaO;
     return (top/bottom)*vertColor*lightIntensity;
}

/* compute specular lighting */
vec4 computeSpecularLighting(in vec4 vertColor, in vec4 normal, in vec4 lightVector, in vec4 eyeVector){
    vec4 specularLighting;

    // shininess and alpha reversed
    float alpha = (2.-shininess/100);
    
    // ThetaD, angle between normal & lightVector we only need its cos value
    vec4 halfVector = normalize(lightVector + eyeVector);
    float cosThethaD = dot(halfVector, lightVector); // /(length(halfVector)*length(lightVector)) ? what is the correct formula? OK because normalize :);
    if(blinnPhong)
        // using the blinn phong model
        specularLighting = specularLightingBP(vertColor, cosThethaD, halfVector, normal);
    else {
        // using the cook torrance model
        specularLighting = specularLightingCT(vertColor, cosThethaD, halfVector, alpha, normal, lightVector, eyeVector);
    }
    return specularLighting; 
}

bool intersectBoundingBox(vec4 origin, vec4 dir) {
    /* check intersection between each plan: 
                x*-orig.x = dir.x*(distance plan)
                distance plan z max = (zmax - orig.z)/dir.z
    */

    // plan 1: z max => compute intersection (x,y)
    float x1 = origin.x+dir.x*((bbmax.z-origin.z)/dir.z);
    float y1 = origin.y+dir.y*((bbmax.z-origin.z)/dir.z);
    // if between min and max for both
    if(bbmin.x <= x1 && x1 <= bbmax.x && bbmin.y <= y1 && y1 <= bbmax.y){
        return true;
    }

    // plan 2: z min => compute intersection (x,y)
    float x2 = origin.x+dir.x*(bbmin.z-origin.z)/dir.z;
    float y2 = origin.y+dir.y*(bbmin.z-origin.z)/dir.z;
    // if between min and max for both
    if(bbmin.x <= x2 && x2 <= bbmax.x && bbmin.y <= y2 && y2 <= bbmax.y){
        return true;
    }

    // plan 3: y max => compute intersection (x,y)
    float x3 = origin.x+dir.x*(bbmax.y-origin.y)/dir.y;
    float z3 = origin.z+dir.z*(bbmax.y-origin.y)/dir.y;
    // if between min and max for both
    if(bbmin.x <= x3 && x3 <= bbmax.x && bbmin.z <= z3 && z3 <= bbmax.z){
        return true;
    }

    // plan 4: y min => compute intersection (x,y)
    float x4 = origin.x+dir.x*(bbmin.y-origin.y)/dir.y;
    float z4 = origin.z+dir.z*(bbmin.y-origin.y)/dir.y;
    // if between min and max for both
    if(bbmin.x <= x4 && x4 <= bbmax.x && bbmin.z <= z4 && z4 <= bbmax.z){
        return true;
    }

    // plan 5: x max => compute intersection (x,y)
    float y5 = origin.y+dir.y*(bbmax.x-origin.x)/dir.x;
    float z5 = origin.z+dir.z*(bbmax.x-origin.x)/dir.x;
    // if between min and max for both
    if(bbmin.y <= y5 && y5 <= bbmax.y && bbmin.z <= z5 && z5 <= bbmax.z){
        return true;
    }

    // plan 6: x min => compute intersection (x,y)
    float y6 = origin.y+dir.y*(bbmin.x-origin.x)/dir.x;
    float z6 = origin.z+dir.z*(bbmin.x-origin.x)/dir.x;
    // if between min and max for both
    if(bbmin.y <= y6 && y6 <= bbmax.y && bbmin.z <= z6 && z6 <= bbmax.z){
        return true;
    }
    return false;
}

bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist) 
{
    // get V0,V1,V2 from vertices (with ptr)
	vec4 v0 = vertices[indices[ptr]];
    vec4 v1 = vertices[indices[ptr + 1]];
    vec4 v2 = vertices[indices[ptr + 2]];

    // compute e1=v1-v0, e2=v2-v0 and t=p-v0 (see slides)
    vec3 e1 = v1.xyz-v0.xyz;
    vec3 e2 = v2.xyz-v0.xyz;
    vec3 t = origin.xyz-v0.xyz;

    // compute q = txe1 and p = dirxe2 (!! vec3 only for cross)
    vec3 q = cross(t,e1);
    vec3 p = cross(dir.xyz,e2);
    
    // compute lambda alpha beta
    // 1/(p.e1)
    float scalar = 1./(dot(p,e1));
    // scalar * (q.e2)
    float lambda = scalar*dot(q,e2);
    // scalar * (p.t)
    float alpha = scalar*dot(p,t);
    // scalar * (q.dir)
    float beta = scalar*dot(q,dir.xyz);
    // 1-alpha-beta
    float betaAlpha = 1.-alpha-beta;

    // if outside the triangle (outside [0,1] for each sides)
    if(alpha < 0 || alpha > 1 || beta < 0 || beta > 1 || betaAlpha < 0 || betaAlpha > 1){
        return false;
    }

    // get the coordinates:
    //          (alpha, beta, betaAlpha, lambda)
    //          P+lambda*u = (1-alpha-beta)*v0 + alpha*v1 + beta*v2
    dist.x = betaAlpha;
    dist.y = alpha;
    dist.z = beta;
    dist.w = lambda;

    return true;
}

vec4 interpolateNormal(hitinfo_t h)
{
	// compute normal of the intersection
    vec4 n0 = normals[indices[h.hit_vptr]];
    vec4 n1 = normals[indices[h.hit_vptr+1]];
    vec4 n2 = normals[indices[h.hit_vptr+2]];
    vec3 coeffs = h.coeffs;
    vec4 normal = normalize((coeffs.x*n0+coeffs.y*n1+coeffs.z*n2));
    return normal;
}

vec4 interpolateColor(hitinfo_t h)
{
    // compute color of the intersection
	vec4 c0 = colors[indices[h.hit_vptr]];
    vec4 c1 = colors[indices[h.hit_vptr+1]];
    vec4 c2 = colors[indices[h.hit_vptr+2]];
    vec3 coeffs = h.coeffs;
    vec4 color = coeffs.x*c0+coeffs.y*c1+coeffs.z*c2;
    return color;
}

/* compute if u intersect with the plane defined by point Q and normal n */
bool rayPlaneIntersect(in vec4 start, in vec4 u, out float lambda){
    // define the plane
    vec4 Q = vec4(0, -groundDistance,0,1);
    vec4 n = vec4(0,1,0,1);

    // compute intersection
    vec4 PQ = (Q-start);
    lambda = (dot(PQ,n)/dot(u,n));
    if(dot(u,n)>0){
        lambda = -lambda;
    }
    if(dot(u,n)>EPS){
        return false;
    }
    if(lambda > 0){
        return true;
    } else {
        return false;
    }
}

bool isIntersected(vec4 origin, vec4 dir, out hitinfo_t h)
{
    h.plan = false;
    vec4 dist; // stores distance + barycentric coord
	bool hit = false;
	h.t.x = radius * MAX_SCENE_BOUNDS;
    float minLambda = 30000000.;
    float lambdaSol = 30000000.;
    
    // see if the ray intersect the box
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
            // see if the ray intersect the triangle
            if(intersectTriangle(origin, dir, j, dist)) {
                // dist = (1-alpha-beta, alpha, beta, lambda);
                // lambda for P+lambda*u (intersection)
                // alpha beta for coord in (v0,v1,v2)
                // j: ptr for the triangle
                if(dist.w < minLambda ){
                    h.t = origin + dist.w*dir;//dist;
                    h.hit_vptr = j;
                    h.coeffs = dist.xyz;
                    minLambda = dist.w;
                    hit = true;
                }
            }
		}
    }
    if(rayPlaneIntersect(origin, dir, lambdaSol)){
        if((lambdaSol<minLambda || hit == false) && lambdaSol >0.01 ){
            h.t = origin + lambdaSol*dir;
            h.hit_vptr = -1;
            h.plan = true;
            hit = true;
        }
    }
	return hit;
}

const int MAX_TRACE = 1;

// checks if a point is illuminated
bool inShadow(hitinfo_t startPoint){
    vec4 dir = normalize(-1*vec4(lightPosition - startPoint.t.xyz, 1));
    hitinfo_t newH;
    bool pInShadow = false;
    if(isIntersected(startPoint.t, dir, newH)){
        if(newH.hit_vptr != startPoint.hit_vptr){
            pInShadow = true;
        }
    }
    return pInShadow;
}

vec4 trace(vec4 origin, vec4 dir)
{
    vec4 resultColor;
    bool hitFloorLast = false;
    intersection_t intersectionInfos[limit];
    hitinfo_t h;
    int counter = 0;
    bool intersect = isIntersected(origin, dir, h); 
    while (counter < min(limit, max(1,numBounds)) && intersect){
        // update information
        vec4 vertNormal;
        vec4 vertColor;
        vec4 eyeVector = normalize(-1*dir);
        intersectionInfos[counter].Direction = eyeVector;
        
        // color
        if(h.plan){
            vertColor = texture2D(colorTexture,h.t.xz/100.);
            if(counter >=1){
                vertColor = vec4(1,0,0,1);
            }
            vertNormal = vec4(0,1,0,1);
            h.hit_vptr = -1;
        } else {
            vertColor = interpolateColor(h);
            vertNormal = interpolateNormal(h);
        }
        
        intersectionInfos[counter].Normals = vertNormal;
        vec4 ambientLighting = computeAmbientLighting(vertColor);

        if(inShadow(h)){
            intersectionInfos[counter].Colors = ambientLighting;
        } else {
            vec4 lightVector = normalize(vec4(lightPosition-h.t.xyz,0));
            // diffuse lighting
            vec4 diffuseLighting = computeDiffuseLighting(vertColor, vertNormal, lightVector);
            // specular lighting
            vec4 specularLighting = computeSpecularLighting(vertColor, vertNormal,lightVector, eyeVector);
            intersectionInfos[counter].Colors = ambientLighting + diffuseLighting + specularLighting;
        }
        // compute fresnel coeff
        float cosThethaD = dot(vertNormal, -1*dir);
        float F = fresnelCoeff(cosThethaD, eta);
        intersectionInfos[counter].Fresnel = F;

        if(dot(dir,vertNormal)>0.){
            intersectionInfos[counter].Colors = vec4(0.,0.,0.,1.);
        }
        // new origin
        origin = h.t;
        dir = normalize(reflect(dir,vertNormal));
        h.plan = false;
        // intersectionInfos[counter].Colors = dir;
        if(counter <limit){
            intersect = isIntersected(origin, dir, h); 
        }
        
        counter += 1;
    }


    /* 3) COMPUTE RESULT COLOR */
    // base: black
    resultColor = vec4(0,0,0,1);//vec4(128, 128, 128, 1)/255.;
    
    // if one bound at least
    if(counter != 0){
        counter-=1;
        // for all the rays
        for(int j = counter; j>=0; j--){
            // color = F(j)*color_next + color(j)
            resultColor =  (intersectionInfos[j].Fresnel)*resultColor + intersectionInfos[j].Colors;
        }
    }
    else{
        resultColor = vec4(128, 128, 128, 1)/255.;
    }
    return resultColor;
	
}

layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {
    ivec2 pix;
    if(alternating > 0){
        pix = ivec2(alternating*gl_GlobalInvocationID.xy);
    } else {
        pix = ivec2(gl_GlobalInvocationID.xy);
    }
    
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = pix / (size - vec2(0.5,0.5)); 
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1.,1.);

    // Step 1: I need pixel coordinates. 
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);

    // alternating rendering
    if(alternating > 0){
        // put the same color for all the pixels around
        for(int i = 0; i <= alternating; i++){
            for(int j = 0; j <= alternating; j++){
                imageStore(framebuffer, ivec2(pix.x+i,pix.y+j), color);
            }
        }
    } else {
        imageStore(framebuffer, pix, color);
    }

}
